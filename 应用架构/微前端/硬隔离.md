# 浏览器硬隔离

组合与隔离，本就是一体两面，往往某种组合方案就自然解决了隔离的痛点，而某种隔离方案又会限制组合的方式。笔者首先从硬/软隔离的角度来对方案进行分类，服务端路由分发与 iFrame 是典型的基于浏览器的硬隔离方案，其天然支持多技术栈、多源的灵活组合，不过其在应用协调与治理方面需要投入较大的精力。Web Components 及其衍生方案同样能带来浏览器级别的隔离与松散的应用协调，但是较差的浏览器兼容性也限制了其应用场景。

## iFrame

iFrame 可以创建一个全新的独立的宿主环境，iFrame 的页面和父页面是分开的，作为独立区域而不受父页面的 CSS 或者全局的 JavaScript 影响。iFrame 的不足或缺陷也非常明显，其会进行资源的重复加载，占用额外的内存；其会阻塞主页面的 onload 事件，和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

iFrame 的改造门槛较低，但是从功能需求的角度看，其无法提供 SEO，并且需要我们自定义应用管理与应用通讯机制。iFrame 的应用管理不仅要关注其加载与生命周期，还需要考虑到浏览器缩放等场景下的界面重适配问题，以提供用户一致的交互体验；这里我们再简要讨论下同源场景中的跨界面通讯解决方案。

> 📖 详细解读参阅 [DOM CheatSheet](https://parg.co/YlB)

- BroadcastChannel

BroadcastChannel 能够用于同源不同页面之间完成通信的功能。它与 window.postMessage 的区别就是，BroadcastChannel 只能用于同源的页面之间进行通信，而 window.postMessage 却可以用于任何的页面之间；BroadcastChannel 可以认为是 window.postMessage 的一个实例，它承担了 window.postMessage 的一个方面的功能。

```js
const channel = new BroadcastChannel("channel-name");

channel.postMessage("some message");
channel.postMessage({ key: "value" });

channel.onmessage = function (e) {
  const message = e.data;
};

channel.close();
```

- SharedWorker API

Shared Worker 类似于 Web Workers，不过其会被来自同源的不同浏览上下文间共享，因此也可以用作消息的中转站。

```js
// main.js
const worker = new SharedWorker("shared-worker.js");

worker.port.postMessage("some message");

worker.port.onmessage = function (e) {
  const message = e.data;
};

// shared-worker.js
const connections = [];

onconnect = function (e) {
  const port = e.ports[0];
  connections.push(port);
};

onmessage = function (e) {
  connections.forEach(function (connection) {
    if (connection !== port) {
      connection.postMessage(e.data);
    }
  });
};
```

- Local Storage

localStorage 是常见的持久化同源存储机制，其会在内容变化时触发事件，也就可以用作同源界面的数据通信。

```js
localStorage.setItem("key", "value");

window.onstorage = function (e) {
  const message = e.newValue; // previous value at e.oldValue
};
```

## Web Components && Shadow DOM

Web Components 的目标是减少单页应用中隔离 HTML，CSS 与 JavaScript 的复杂度，其主要包含了 Custom Elements, Shadow DOM, Template Element，HTML Imports，Custom Properties 等多个维度的规范与实现。Shadow DOM 它允许在文档（document）渲染时插入一棵 DOM 元素子树，但是这棵子树不在主 DOM 树中。因此开发者可利用 Shadow DOM 封装自己的 HTML 标签、CSS 样式和 JavaScript 代码。子树之间可以相互嵌套，对其中的内容进行了封装，有选择性的进行渲染。这就意味着我们可以插入文本、重新安排内容、添加样式等等。其结构示意如下：

![image](https://user-images.githubusercontent.com/5803001/43813782-c17e5d34-9af9-11e8-94df-7974298a2afc.png)

简单的 Shadow DOM 创建方式如下：

```html
<html>
  <head></head>
  <body>
    <p id="hostElement"></p>
    <script>
      // 创建 shadow DOM
      var shadow = document
        .querySelector("#hostElement")
        .attachShadow({ mode: "open" });
      // 给 shadow DOM 添加文字
      shadow.innerHTML = "<p>Here is some new text</p>";
      // 添加CSS，将文字变红
      shadow.innerHTML += "<style>p { color: red; }</style>";
    </script>
  </body>
</html>
```

我们也可以将 React 应用封装为 Custom Element 并且封装到 Shadow DOM 中：

```js
import React from "react";
import retargetEvents from "react-shadow-dom-retarget-events";

class App extends React.Component {
  render() {
    return <div onClick={() => alert("I have been clicked")}>Click me</div>;
  }
}

const proto = Object.create(HTMLElement.prototype, {
  attachedCallback: {
    value: function () {
      const mountPoint = document.createElement("span");
      const shadowRoot = this.createShadowRoot();
      shadowRoot.appendChild(mountPoint);
      ReactDOM.render(<App />, mountPoint);
      retargetEvents(shadowRoot);
    },
  },
});
document.registerElement("my-custom-element", { prototype: proto });
```

Shadow DOM 的兼容性较差，仅在 Chrome 较高版本浏览器中可以使用。
