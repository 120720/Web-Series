![image](https://user-images.githubusercontent.com/5803001/45917560-72887d00-beac-11e8-896e-f41eabed0a8c.png)

# Web 解析与渲染

导航过程完成之后，浏览器进程把数据交给了渲染进程，渲染进程负责 tab 内的所有事情，核心目的就是将 HTML/CSS/JS 代码，转化为用户可进行交互的 Web 页面。渲染进程中，包含线程分别是：一个主线程（main thread）、多个工作线程（work thread）、一个合成器线程（compositor thread）、多个光栅化线程（raster thread）。

![渲染进程包含的子线程](https://s1.ax1x.com/2020/11/06/BfS30H.md.png)

# DOM 构建与资源子加载

当渲染进程接受到导航的确认信息后，开始接受来自浏览器进程的数据，这个时候，主线程会解析数据转化为 DOM（Document Object Model）对象。DOM 为 Web 开发人员通过 JavaScript 与网页进行交互的数据结构及 API。在构建 DOM 的过程中，会解析到图片、CSS、JavaScript 脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建 DOM 过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果如果 HTML 中存在 img、link 等标签，预加载扫描程序会把这些请求传递给 Browser Process 的 network thread 进行资源下载。

![资源预加载](https://s1.ax1x.com/2020/11/06/BfSxDe.md.png)

# JavaScript 解析与编译

构建 DOM 过程中，如果遇到 `<script>` 标签，渲染引擎会停止对 HTML 的解析，而去加载执行 JS 代码，原因在于 JS 代码可能会改变 DOM 的结构（比如执行 document.write()等 API）。不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在 `<script>` 标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行 JS 代码，而不会阻塞渲染。

V8 及 Chrome 团队也是一直致力于提升 JavaScript 引擎的解析与编译性能。较老版本的 Chrome 会等待脚本全部下载完毕后再进行解析，而新版本的 Chrome 中，会使用独立地工作线程来解析 async 或者 deferred 的脚本，而不会再去阻塞主线程。并且在许多真实场景下，V8 解析的速度会远快于下载速度，因此脚本往往在下载以后的数毫秒内即可以完成解析与编译。

![V8 多线程解析示意图](https://i.postimg.cc/Y0r3vzTS/image.png)

# 样式计算（Style Calculation）

DOM 树只是我们页面的结构，我们要知道页面长什么样子，我们还需要知道 DOM 的每一个节点的样式。主线程在解析页面时，遇到 `<style>` 标签或者 `<link>` 标签的 CSS 资源，会加载 CSS 代码，根据 CSS 代码确定每个 DOM 节点的计算样式（computed style）。计算样式是主线程根据 CSS 样式选择器（CSS selectors）计算出的每个 DOM 元素应该具备的具体样式，即使你的页面没有设置任何自定义的样式，浏览器也会提供其默认的样式。

![样式计算](https://s1.ax1x.com/2020/11/06/BfpfPI.png)

# 布局（Layout）

DOM 树和计算样式完成后，我们还需要知道每一个节点在页面上的位置，布局（Layout）其实就是找到所有元素的几何关系的过程。主线程会遍历 DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none），另外，伪元素虽然在 DOM 上不可见，但是在布局树上是可见的。
